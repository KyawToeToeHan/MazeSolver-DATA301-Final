# -*- coding: utf-8 -*-
"""MazeSolver

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ioe0sUAXaw9X7abhMZNRadd_TP2AjA_c
"""

from collections import deque
import heapq

# Directions: up, down, left, right
moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

"""**Load mazes**"""

def load_mazes_from_file(filename):
    mazes = []
    current_maze = []
    with open(filename, 'r') as file:
        for line in file:
            line = line.strip()
            if line == "":
                if current_maze:
                    mazes.append(current_maze)
                    current_maze = []
            else:
                row = [int(x) for x in line.split()]
                current_maze.append(row)
        if current_maze:
            mazes.append(current_maze)
    return mazes

# Check if a move is valid
def is_valid(maze, visited, row, col):
    rows, cols = len(maze), len(maze[0])
    return 0 <= row < rows and 0 <= col < cols and maze[row][col] == 0 and not visited[row][col]

# Build path from parent map
def build_path(parent, start, end):
    path = []
    curr = end
    while curr != start:
        path.append(curr)
        curr = parent.get(curr)
        if curr is None:
            return None
    path.append(start)
    path.reverse()
    return path

# BFS Algorithm
def bfs(maze, start, end):
    rows, cols = len(maze), len(maze[0])
    visited = [[False]*cols for _ in range(rows)]
    parent = {}
    queue = deque([start])
    visited[start[0]][start[1]] = True

    while queue:
        current = queue.popleft()
        if current == end:
            break
        for dr, dc in moves:
            r, c = current[0] + dr, current[1] + dc
            if is_valid(maze, visited, r, c):
                visited[r][c] = True
                parent[(r, c)] = current
                queue.append((r, c))

    return build_path(parent, start, end)

# DFS Algorithm
def dfs(maze, start, end):
    rows, cols = len(maze), len(maze[0])
    visited = [[False]*cols for _ in range(rows)]
    parent = {}
    stack = [start]
    visited[start[0]][start[1]] = True

    while stack:
        current = stack.pop()
        if current == end:
            break
        for dr, dc in moves:
            r, c = current[0] + dr, current[1] + dc
            if is_valid(maze, visited, r, c):
                visited[r][c] = True
                parent[(r, c)] = current
                stack.append((r, c))

    return build_path(parent, start, end)

# Dijkstra's Algorithm
def dijkstra(maze, start, end):
    rows, cols = len(maze), len(maze[0])
    distances = [[float('inf')]*cols for _ in range(rows)]
    distances[start[0]][start[1]] = 0
    parent = {}
    heap = [(0, start)]

    while heap:
        cost, current = heapq.heappop(heap)
        if current == end:
            break
        for dr, dc in moves:
            r, c = current[0] + dr, current[1] + dc
            if 0 <= r < rows and 0 <= c < cols and maze[r][c] == 0:
                new_cost = cost + 1
                if new_cost < distances[r][c]:
                    distances[r][c] = new_cost
                    parent[(r, c)] = current
                    heapq.heappush(heap, (new_cost, (r, c)))

    path = build_path(parent, start, end)
    return path, distances[end[0]][end[1]] if path else float('inf')

# Display maze with path
def display_maze(maze, path, start, end):
    path_set = set(path) if path else set()
    for r in range(len(maze)):
        row_display = ""
        for c in range(len(maze[0])):
            pos = (r, c)
            if pos == start:
                row_display += 'S '
            elif pos == end:
                row_display += 'E '
            elif maze[r][c] == 1:
                row_display += '# '
            elif pos in path_set:
                row_display += '. '
            else:
                row_display += '  '
        print(row_display)
    print()

def main():
    filename = input("Enter maze file name (e.g., mazes.txt): ")
    try:
        all_mazes = load_mazes_from_file(filename)
    except Exception as e:
        print(f"Error reading file: {e}")
        return

    for i, maze in enumerate(all_mazes):
        print(f"\n=== Maze {i+1} ===")
        start = (0, 0)
        end = (len(maze) - 1, len(maze[0]) - 1)

        if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1:
            print("Start or end is blocked. Skipping this maze.")
            continue

        print("Choose an algorithm:")
        print("1. BFS")
        print("2. DFS")
        print("3. Dijkstra")
        choice = input("Enter your choice (1-3): ")

        path = None
        cost = None

        if choice == '1':
            path = bfs(maze, start, end)
            print("BFS Path:")
        elif choice == '2':
            path = dfs(maze, start, end)
            print("DFS Path:")
        elif choice == '3':
            path, cost = dijkstra(maze, start, end)
            print("Dijkstra Path:")
        else:
            print("Invalid choice. Skipping this maze.")
            continue  # Go to the next maze

        display_maze(maze, path, start, end)

        if path:
            if choice == '3':
                print(f"Path cost: {cost}")
            else:
                print(f"Path cost: {len(path) - 1}")
        else:
            print("No path found.")

# Entry point
if __name__ == "__main__":
    main()